import { expect, test } from '@playwright/test';
import * as userData from '../../fixtures/users';
import { describeWithSetup } from '../../shared/base-test';
import * as browsers from '../../shared/interactions/browsers';
import * as ideas from '../../shared/interactions/ideas';
import * as navigation from '../../shared/interactions/navigation';
import * as rooms from '../../shared/interactions/rooms';
import * as shared from '../../shared/shared';

const getUsers = () => {
  // Ensure users are initialized when accessed
  if (!userData.alice) userData.init();
  return [userData.testUsers.alice(), userData.testUsers.bob()];
};

// force these tests to run sqeuentially
test.describe.configure({ mode: 'serial' });

describeWithSetup('Idea Management - CRUD Operations and Permissions', () => {
  let admin: any;
  let alice: any;
  let bob: any;

  const room = {
    name: `room-${shared.getRunId()}-idea-tests`,
    description: 'created during automated testing for idea-management.spec.ts',
    users: getUsers(),
  };

  const adminIdea = {
    name: `admin-${shared.getRunId()}-idea-tests`,
    description: 'Idea generated by Admin during automated testing for idea-management.spec.ts',
    comment: `Alice commented on Admin's idea`,
  };

  const aliceIdea = {
    name: `alice-${shared.getRunId()}-idea-tests`,
    description: 'Idea generated by Alice during automated testing for idea-management.spec.ts',
    comment: `Bob commented on Admin's idea`,
  };

  test.beforeAll(async () => {
    admin = await browsers.newPage(browsers.admins_browser);
    alice = await browsers.newPage(browsers.alices_browser);
    bob = await browsers.newPage(browsers.bobs_browser);
  });

  const cleanupQueue = {
    room: false,
    adminIdea: false,
    aliceIdea: false,
  };

  const cleanup = async () => {
    if (cleanupQueue.adminIdea) await ideas.remove(admin, room, adminIdea);
    cleanupQueue.adminIdea = false;

    if (cleanupQueue.aliceIdea) await ideas.remove(alice, room, aliceIdea);
    cleanupQueue.aliceIdea = false;

    if (cleanupQueue.room) await rooms.remove(admin, room);
    cleanupQueue.room = false;
  };

  test.afterAll(async () => {
    await cleanup();
    await admin.close();
    await alice.close();
    await bob.close();
  });

  test('Admin can create an idea', async () => {
    await rooms.create(admin, room);
    cleanupQueue.room = true;

    await ideas.create(admin, room, adminIdea);
    cleanupQueue.adminIdea = true;
  });

  test('Users can create an idea', async () => {
    await ideas.create(alice, room, aliceIdea);
    cleanupQueue.aliceIdea = true;
  });

  test('Users cannot delete other users ideas', async () => {
    await expect(async () => {
      await ideas.remove(bob, room, aliceIdea);
    }).rejects.toThrow();
  });

  test('Users can add comments to ideas', async () => {
    await navigation.goToWildIdea(alice, room.name, adminIdea.name);
    await ideas.comment(alice, adminIdea.comment);

    await navigation.goToWildIdea(bob, room.name, aliceIdea.name);
    await ideas.comment(bob, aliceIdea.comment);
  });

  test('Users can delete their own comments', async () => {
    await navigation.goToWildIdea(alice, room.name, adminIdea.name);
    await ideas.removeComment(alice, adminIdea.comment);
  });

  test('Users cannot delete other users comments', async () => {
    await navigation.goToWildIdea(alice, room.name, aliceIdea.name);
    await expect(async () => {
      await ideas.removeComment(alice, aliceIdea.comment);
    }).rejects.toThrow();
  });

  test('Admin can delete an idea', async () => {
    await ideas.remove(admin, room, adminIdea);
    cleanupQueue.adminIdea = false;
  });

  test('Alice can delete her own idea', async () => {
    await ideas.remove(alice, room, aliceIdea);
    cleanupQueue.aliceIdea = false;
  });
});
